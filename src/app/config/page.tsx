/* eslint-disable */
"use client";
import styles from "./config.module.css";
import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import * as webllm from "@mlc-ai/web-llm";

interface Byte {
    title: string;
    description: string;
    tag: string;
    longdescription: string;
    mainlink: string;
    otherlinks?: string[];
    backgroundColor?: string;
    headerPatternColors?: { [key: string]: string };
    patternClass?: string;
}

interface StoreByteRequest{
    userID: string,
    bytes: Byte[],
    nextByte: boolean
}

export default function Config() {

    const [session, setSession] = useState<{
        userId: string;
        email: string;
        username: string;
        docks?: any;
    } | null>(null);

    const router = useRouter();
    const [fullTopics, setFullTopics] = useState<string[]>([]);
    const [userAddedTopics, setUserAddedTopics] = useState<string[]>([]);
    const [newTopic, setNewTopic] = useState<string>("");
    const [frequency, setFrequency] = useState<string>("hourly");
    const [allQueries, setAllQueries] = useState<string[][]>([]); // Store all generated queries
    const [loading, setLoading] = useState<boolean>(false); // Loading state for overlay
    const [secondRound, setSecondRound] = useState<boolean>(false)

    const handleTopicClick = (topic: string) => {
        setFullTopics((prevTopics) =>
            prevTopics.includes(topic)
                ? prevTopics.filter((t) => t !== topic)
                : [...prevTopics, topic]
        );
    };

    const handleAddTopic = () => {
        if (newTopic && !userAddedTopics.includes(newTopic)) {
            setUserAddedTopics((prevTopics) => [...prevTopics, newTopic]);
            setFullTopics((prevTopics) => [...prevTopics, newTopic]);
            setNewTopic(""); // Clear input field
        }
    };

    const handleSave = async () => {
        try {
            const response = await fetch("/api/config/topics", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({ userID: session?.userId, topics: fullTopics }),
            });

            if (response.ok) {
                console.log("Topics saved successfully!");
                
                await generateQueriesForTopics(fullTopics); // Call the LLM prompt function here
            } else {
                console.error("Failed to save topics");
                await generateQueriesForTopics(fullTopics);
            }
        } catch (error) {
            console.error("Error saving topics:", error);
        }
    };

    // Function to post the generated queries to /api/internet
    // const postQueriesToAPI = async (queries: string[][]) => {
    //     try {
    //         const response = await fetch("/api/internet", {
    //             method: "POST",
    //             headers: {
    //                 "Content-Type": "application/json",
    //             },
    //             body: JSON.stringify({ queries }), // Send the queries as the request body
    //         });

    //         if (response.ok) {
    //             const urls: string[][] = await response.json(); // Assuming the API returns a list of URLs
    //             console.log("URLs received from /api/internet:", urls);
    //             // Optionally: Display or handle the URLs here
    //         } else {
    //             console.error("Failed to get URLs from /api/internet");
    //         }
    //     } catch (error) {
    //         console.error("Error posting queries to /api/internet:", error);
    //     }
    // };

    const postQueriesToAPI = async (queries: string[][]) => {
        try {
            const response = await fetch("/api/internet", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({ queries }), // Send the queries as the request body
            });
    
            if (response.ok) {
                const urls: string[][][] = await response.json(); // Higher-dimensional array of URLs
                console.log("URLs received from /api/internet:", urls);
    
                // Arrays to store HTML content and generated bytes
                const stringifiedHTMLExtracted: string[][][] = [];
                const generatedBytes: Byte[][] = []; // To store the final bytes per query group
    
                // Loop through the topics
                for (let i = 0; i < urls.length; i++) {
                    const topicUrls: string[][] = urls[i]; // Array of URL arrays for this topic
                    const topicHTML: string[][] = [];
                    const topicBytes: Byte[] = []; // Store the bytes for each query group
    
                    // Loop through the queries for this topic
                    for (let j = 0; j < topicUrls.length; j++) {
                        const queryUrls: string[] = topicUrls[j]; // Array of URLs for this query
                        const queryHTML: string[] = [];
    
                        // Loop through the URLs for this query
                        for (let k = 0; k < queryUrls.length; k++) {
                            const url = queryUrls[k];
                            try {
                                const htmlResponse = await fetch(url);
                                const htmlText = await htmlResponse.text(); // Get the HTML text
                                queryHTML.push(htmlText); // Add the HTML text to the array for this query
    
                                // Define the JSON schema for a `Byte` object
                                const byteSchema = {
                                    type: "object",
                                    properties: {
                                        title: { type: "string" },
                                        description: { type: "string" },
                                        tag: { type: "string" },
                                        longdescription: { type: "string" },
                                        mainlink: { type: "string" },
                                        otherlinks: {
                                            type: "array",
                                            items: { type: "string" },
                                        },
                                    },
                                    required: ["title", "description", "tag", "longdescription", "mainlink"],
                                };
    
                                // Prompt the LLM to generate the `Byte` for the HTML and corresponding query
                                const bytePrompt = `
                                    You are a content creation agent. Your job is to generate a \`Byte\` for the following HTML content based on the query: "${queries[i][j]}". 
                                    The \`Byte\` object must include a title (a heading for the byte), description (must be one paragraph), tag (a tag for the category of topic this is), longdescription (must be 3 paragraphs), mainlink (main reference link for byte), and optionally other reference links. 
                                    Format the response in JSON based on the provided schema.
                                    HTML Content: ${htmlText}
                                `;
    
                                // Call LLM to generate the `Byte`
                                const byteResult = await promptLLMJSONSchema(byteSchema, bytePrompt, "Qwen2.5-1.5B-Instruct-q4f16_1-MLC");
    
                                if (byteResult) {
                                    topicBytes.push(byteResult); // Add the generated `Byte` object to the list
                                } else {
                                    console.error(`Failed to generate Byte for query: "${queries[i][j]}"`);
                                }
    
                            } catch (error) {
                                console.error(`Failed to fetch or generate Byte for HTML from ${url}:`, error);
                                queryHTML.push(`Failed to fetch from ${url}`);
                            }
                        }
    
                        topicHTML.push(queryHTML); // Add the query HTML array to the topic
                    }
    
                    stringifiedHTMLExtracted.push(topicHTML); // Add the topic's HTML arrays to the final array
                    generatedBytes.push(topicBytes); // Add the generated bytes for the topic
                }
    
                console.log("HTML Extracted from URLs:", stringifiedHTMLExtracted);
                console.log("Generated Bytes:", generatedBytes);
                // Now you have `generatedBytes` array containing the generated Byte objects per query group.
                const flattenedGeneratedBytes: Byte[] = generatedBytes.flat();

                const params: StoreByteRequest = {
                    userID: session!.userId,
                    bytes: flattenedGeneratedBytes,
                    nextByte: secondRound,
                }

                const storesponse = await fetch("/api/bytes/store", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(params), // Send the queries as the request body
                });

                if (storesponse.ok) {

                    if (secondRound){
                        confirm("Your bytes have been generated. Ready to Byte?")
                        router.push("/byte");
                    }

                    // do it all again
                    setSecondRound(true);
                    await generateQueriesForTopics(fullTopics);
                    


                    
                } else {
                    try {
                        const storesponse = await fetch("/api/bytes/store", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify(params), // Send the queries as the request body
                        });

                        if(storesponse.ok){

                            if (secondRound){
                                confirm("Your bytes have been generated. Ready to Byte?")
                                router.push("/byte");
                            }
        
                            // do it all again
                            setSecondRound(true);
                            await generateQueriesForTopics(fullTopics);

                        } else {
                            throw new Error("Error Getting Bytes. Please refresh the page and try again")
                        }
                    } catch (error) {
                        alert("Error Getting Bytes. Please refresh the page and try again.")
                    }
                }


    
            } else {
                console.error("Failed to get URLs from /api/internet");
            }
        } catch (error) {
            console.error("Error posting queries to /api/internet:", error);
        }
    };
    
    
    

    // Function to generate queries for randomly selected topics using the LLM
    const generateQueriesForTopics = async (topics: string[]) => {
        setLoading(true); // Show loading overlay
        const selectedTopics = topics.length > 10
            ? topics.sort(() => 0.5 - Math.random()).slice(0, 10)  // Randomly select 20 topics
            : topics;  // Use all topics if there are 20 or fewer

        const allGeneratedQueries: string[][] = [];

        // Loop through each topic and prompt LLM individually
        for (const topic of selectedTopics) {
            const schema = {
                type: "object",
                properties: {
                    queries: {
                        type: "array",
                        items: { type: "string" }
                    }
                },
                required: ["queries"]
            };

            const examplePrompt = `Important: your arraay must always be of length 10 (You should always have 10 queries). You are a news curation agent. Your job is to generate queries for topics to search the internet and provide new and unique information to the user. Generate a list of 10 unique internet queries for each of the the following topic that will provide the user with valuable and diverse knowledge with different perspectives for the topic. Choose a specific theme for each of the 10 queries you generate so that they can provide specific and welll rounded information on the specific idea/subtopic reltaed to the topic. Your queries should be random and specific. If I ask you again with the same prompt to generate queries, your answers should be different from the first time I asked. Topic: ${topic}.`;
            const modelId = "Qwen2.5-1.5B-Instruct-q4f16_1-MLC"; // Example model ID

            const result = await promptLLMJSONSchema(schema, examplePrompt, modelId);

            if (result?.queries && Array.isArray(result.queries)) {
                allGeneratedQueries.push([result.queries]); // Add generated queries to the array
                console.log("added to allgeneratedqueries")
                console.log(allGeneratedQueries)
            }
        }

        setAllQueries(allGeneratedQueries); // Store all queries in state
        // Once all queries are generated, send them to /api/internet
        await postQueriesToAPI(allGeneratedQueries);
        setLoading(false); // Hide loading overlay
    };

    // Define the LLM prompting logic
    const promptLLMJSONSchema = async (schema: any, prompt: string, modelId: string): Promise<any> => {
        const schemaString = JSON.stringify(schema);
        const initProgressCallback = (report: webllm.InitProgressReport) => {
            console.log("LLM Initialization:", report.text);
        };

        const engine: webllm.MLCEngineInterface = await webllm.CreateMLCEngine(modelId, { initProgressCallback });

        const request: webllm.ChatCompletionRequest = {
            stream: false,
            messages: [
                {
                    role: "user",
                    content: prompt,
                },
            ],
            max_tokens: 8000,
            response_format: {
                type: "json_object",
                schema: schemaString,
            } as webllm.ResponseFormat,
        };

        try {
            console.log("Message about to be sent to chat completion")
            const completion = await engine.chatCompletion(request);
            const output = completion.choices[0]?.message?.content;  // Access the generated content
            console.log("Generated JSON Output:", output);
            return JSON.parse(output!); // Parse the JSON response
        } catch (error) {
            console.error("Error generating JSON based on schema:", error);
            try{
                console.log("Trying to generate schema again")
                const completion = await engine.chatCompletion(request);
                const output = completion.choices[0]?.message?.content;  // Access the generated content
                console.log("Generated JSON Output:", output);
                return JSON.parse(output!); // Parse the JSON response
            } catch {
                console.log("Ultimate Fail")
                return null
            }
        }
    };

    // Fetch topics for the current user
    const fetchUserTopics = async (userId: string) => {
        try {
            const response = await fetch(`/api/config/topics/${userId}`);
            if (response.ok) {
                const { topics } = await response.json();
                console.log("User topics fetched successfully:", topics);
                setFullTopics(topics); // Set the user's topics
            } else {
                console.error("Failed to fetch user topics, proceeding with blank.");
            }
        } catch (error) {
            console.error("Error fetching user topics:", error);
        }
    };

    useEffect(() => {
        const fetchSession = async () => {
            try {
                const response = await fetch("/api/auth/session");
                if (response.ok) {
                    const data = await response.json();
                    setSession(data);
                    // Fetch the user's topics
                    if (data.userId) {
                        await fetchUserTopics(data.userId); // Fetch user-specific topics
                    }
                } else {
                    router.push("/login");
                }
            } catch (error) {
                console.error("Error fetching session:", error);
                router.push("/login");
            }
        };

        if (!session) {
            fetchSession();
        }

    }, [router, session]);

    const handleLogout = async () => {
        try {
            const response = await fetch("/api/auth/logout", { method: "POST" });
            if (response.ok) {
                router.push("/login");
            } else {
                console.error("Logout failed");
            }
        } catch (error) {
            console.error("Logout error:", error);
        }
    };

    return (
        <div className={styles.page}>
            {loading && ( // Display loading overlay when generating queries
                <div className={styles.loadingOverlay}>
                    <div className={styles.loadingText}>
                        <p className={styles.loadingTitle}>Take a break :) You'll be notified when your bytes are ready.</p>
                        <p className={styles.loadingSubtitle}>Generating your Bytes... Please do not exit the page.</p>
                    </div>
                </div>
            )}

            <div className={styles.header}>
                <div className={styles.logoText}>
                    <a href="/home">
                        <span className={styles.logospan}>BYTESIZE</span>
                    </a>
                </div>
                <div className={styles.session}>
                    {session ? (
                        <a href="/home">
                        <span >Back Home</span>
                    </a>
                    ) : (
                        <p className={styles.sessionText}>Loading...</p>
                    )}
                </div>
            </div>

            <div className={styles.content}>

                <div className={styles.selectionHeader}>
                    {/* Display the number of selected topics */}
                    <div className={styles.topicCount}>
                        <p>Selected Topics: {fullTopics.length}</p>
                    </div>

                    {/* Dropdown for frequency selection */}
                    <div className={styles.frequency}>
                        <label htmlFor="frequency">Get new bytes every: </label>
                        <select
                            id="frequency"
                            value={frequency}
                            onChange={(e) => setFrequency(e.target.value)}
                        >
                            <option value="1">Hour</option>
                            <option value="2">3 Hours</option>
                            <option value="6">6 Hours</option>
                            <option value="12">12 Hours</option>
                            <option value="24">24 hours</option>
                        </select>
                    </div>

                    {/* Input for adding new topics */}
                    <div className={styles.addTopic}>
                        <input
                            type="text"
                            value={newTopic}
                            onChange={(e) => setNewTopic(e.target.value)}
                            placeholder="Add a new topic..."
                        />

                        <button onClick={handleAddTopic}>Add Topic</button>
                    </div>

                    {/* Save button */}
                    <div className={styles.saveButton}>
                        <button onClick={handleSave}>Save Changes</button>
                    </div>
                </div>

                    <div> Select at least 10 topics for best results</div>
                {/* Section for user-added topics */}
                <div className={styles.topicGroup}>
                    <h3>Your Added Topics</h3>
                    <div className={styles.topics}>
                        {userAddedTopics.map((topic) => (
                            <button
                                key={topic}
                                className={fullTopics.includes(topic) ? styles.selectedButton : styles.deSelectedButton}
                                onClick={() => handleTopicClick(topic)}
                            >
                                {topic}
                            </button>
                        ))}
                    </div>
                </div>
                 {/* Render default topics */}
                 <div className={styles.chooseTopics}>
                    {defaultTopics.map((group) => (
                        <div key={group.title} className={styles.topicGroup}>
                            <h3>{group.title}</h3>
                            <div className={styles.topics}>
                                {group.topics.map((topic) => (
                                    <button
                                        key={topic}
                                        className={fullTopics.includes(topic) ? styles.selectedButton : styles.deSelectedButton}
                                        onClick={() => handleTopicClick(topic)}
                                    >
                                        {topic}
                                    </button>
                                ))}
                            </div>
                        </div>
                    ))}
                </div>
            </div>

            <div className={styles.footer}></div>
        </div>
    );
}               

interface TopicGroup {
    title: string;
    topics: string[];
}
  

const defaultTopics: TopicGroup[] = [
    {
      title: "Technology",
      topics: [
        "Artificial Intelligence",
        "Blockchain",
        "Cloud Computing",
        "Cybersecurity",
        "Quantum Computing",
        "5G Networks",
        "IoT (Internet of Things)",
        "Virtual Reality",
        "Augmented Reality",
        "Automation",
        "Edge Computing",
        "Wearables",
        "Robotics",
        "Smart Cities",
        "Digital Transformation",
        "Data Science",
        "Machine Learning",
        "Big Data Analytics",
        "DevOps",
        "Web3",
        "Cryptocurrency",
        "Natural Language Processing",
        "Serverless Computing",
        "SaaS (Software as a Service)",
        "FinTech",
        "EdTech",
        "Digital Health",
        "Tech Startups",
        "Biometrics",
        "Autonomous Vehicles",
        "Drones",
      ],
    },
    {
      title: "Business & Finance",
      topics: [
        "Stock Market",
        "Investment Strategies",
        "Cryptocurrency",
        "Venture Capital",
        "Startups",
        "FinTech",
        "Mergers and Acquisitions",
        "Personal Finance",
        "Real Estate",
        "Financial Planning",
        "E-commerce",
        "Corporate Governance",
        "Global Markets",
        "Taxation",
        "Financial Regulation",
        "Wealth Management",
        "Banking Industry",
        "Insurance",
        "Business Innovation",
        "Market Trends",
        "Crowdfunding",
        "IPO (Initial Public Offering)",
        "Private Equity",
        "Small Business",
        "Entrepreneurship",
        "Sustainable Investing",
        "Bonds",
        "Commodities",
        "Economic Policies",
        "Risk Management",
      ],
    },
    {
      title: "Science",
      topics: [
        "Astrophysics",
        "Biotechnology",
        "Genetics",
        "Climate Science",
        "Space Exploration",
        "Quantum Physics",
        "Neuroscience",
        "Ecology",
        "Environmental Science",
        "Microbiology",
        "Paleontology",
        "Nanotechnology",
        "Geology",
        "Marine Biology",
        "Astronomy",
        "Evolutionary Biology",
        "Molecular Biology",
        "Physics",
        "Renewable Energy",
        "Medical Research",
        "CRISPR Technology",
        "Sustainable Energy",
        "Climate Change Mitigation",
        "Conservation Biology",
        "Biochemistry",
        "Theoretical Physics",
        "Human Genome Project",
        "Virology",
        "Botany",
        "Archaeology",
      ],
    },
    {
      title: "Politics & Government",
      topics: [
        "Elections",
        "Legislation",
        "Government Policies",
        "Political Parties",
        "International Relations",
        "Diplomacy",
        "Trade Agreements",
        "Global Politics",
        "Public Opinion",
        "Political Theories",
        "Campaign Strategies",
        "Government Funding",
        "Tax Reform",
        "Healthcare Policies",
        "Political Movements",
        "Constitutional Law",
        "Civil Rights",
        "Lobbying",
        "Environmental Policies",
        "Foreign Policy",
        "Human Rights",
        "Immigration Policies",
        "Military Strategy",
        "Economic Policies",
        "Public Services",
        "Cybersecurity Policy",
        "Geopolitics",
        "Supreme Court Decisions",
        "National Security",
        "Peacekeeping Missions",
      ],
    },
    {
      title: "Health & Wellness",
      topics: [
        "Mental Health",
        "Nutrition",
        "Fitness",
        "Sleep",
        "Stress Management",
        "Mindfulness",
        "Exercise Science",
        "Healthy Aging",
        "Chronic Disease",
        "Holistic Health",
        "Yoga",
        "Meditation",
        "Healthy Eating",
        "Weight Loss",
        "Women's Health",
        "Men's Health",
        "Cardiovascular Health",
        "Gut Health",
        "Immunity",
        "Fitness Trends",
        "Physical Therapy",
        "Public Health",
        "Wellness Coaching",
        "Rehabilitation",
        "Pediatric Health",
        "Occupational Health",
        "Skin Care",
        "Alternative Medicine",
        "COVID-19",
        "Preventive Medicine",
      ],
    },
    {
      title: "Entertainment",
      topics: [
        "Movies",
        "Television",
        "Music",
        "Celebrity News",
        "Streaming Platforms",
        "Video Games",
        "Comics",
        "Anime",
        "Manga",
        "Theater",
        "Film Reviews",
        "Music Festivals",
        "Awards Shows",
        "Concerts",
        "Dance",
        "Reality TV",
        "Film Production",
        "Box Office Trends",
        "Indie Films",
        "Pop Culture",
        "Music Charts",
        "Actors and Actresses",
        "Directors",
        "Music Production",
        "Film Criticism",
        "TV Series",
        "Music Genres",
        "Soundtracks",
        "Fan Theories",
        "Behind the Scenes",
      ],
    },
    {
      title: "Sports",
      topics: [
        "Football (Soccer)",
        "Basketball",
        "Baseball",
        "Tennis",
        "Cricket",
        "Rugby",
        "Golf",
        "Olympics",
        "Esports",
        "Track and Field",
        "American Football",
        "Hockey",
        "Boxing",
        "MMA (Mixed Martial Arts)",
        "Formula 1",
        "NASCAR",
        "Cycling",
        "Skiing",
        "Surfing",
        "Skateboarding",
        "Motorsports",
        "Swimming",
        "Wrestling",
        "Rowing",
        "Badminton",
        "Volleyball",
        "Ice Hockey",
        "Extreme Sports",
        "Gymnastics",
        "Horse Racing",
      ],
    },
    {
      title: "Lifestyle",
      topics: [
        "Travel",
        "Food & Drink",
        "Home Decor",
        "Fashion",
        "Beauty",
        "Personal Finance",
        "Relationships",
        "Parenting",
        "Pet Care",
        "Interior Design",
        "Sustainable Living",
        "Minimalism",
        "Home Improvement",
        "Self-Care",
        "Hobbies",
        "DIY Projects",
        "Gardening",
        "Photography",
        "Crafting",
        "Cooking",
        "Baking",
        "Luxury Travel",
        "Fitness Lifestyle",
        "Veganism",
        "Ethical Fashion",
        "Budget Travel",
        "Home Organization",
        "Personal Development",
        "Mindfulness Lifestyle",
        "Remote Work",
      ],
    },
    {
      title: "Education",
      topics: [
        "Online Learning",
        "Higher Education",
        "STEM Education",
        "EdTech",
        "Language Learning",
        "Special Education",
        "Adult Learning",
        "Primary Education",
        "Secondary Education",
        "Teacher Training",
        "Vocational Training",
        "College Admissions",
        "Scholarships",
        "Student Life",
        "E-learning Platforms",
        "Coding Bootcamps",
        "Educational Policy",
        "Virtual Classrooms",
        "Open Education Resources",
        "Home Schooling",
        "Early Childhood Education",
        "Lifelong Learning",
        "Distance Learning",
        "Educational Research",
        "Online Certifications",
        "Educational Innovation",
        "STEM Careers",
        "Curriculum Development",
        "Learning Disabilities",
        "Study Tips",
      ],
    },
    {
      title: "Arts & Culture",
      topics: [
        "Art History",
        "Contemporary Art",
        "Literature",
        "Poetry",
        "Photography",
        "Sculpture",
        "Painting",
        "Cultural Heritage",
        "Architecture",
        "Music Composition",
        "Classical Music",
        "Film Art",
        "Graphic Design",
        "Typography",
        "Street Art",
        "Illustration",
        "Visual Arts",
        "Performing Arts",
        "Dance",
        "Opera",
        "Theater Production",
        "Art Exhibitions",
        "Museums",
        "Cultural Criticism",
        "World Culture",
        "Cultural Anthropology",
        "Fine Arts",
        "Multimedia Art",
        "Digital Art",
        "Public Art",
      ],
    },
  ];
  